#' Stub docs: Predict method
#'
#' Supports specifying the the dates for prediction four ways:
#' 1. Passing fit and not specifying any date arguments. In this
#'  predictions are returned for the dates in between the minimum and maximum
#'  dates passed to [RtGam()].
#' 2. Specifying `horizon`. A forecast of `horizon` days is returned, starting
#'  from last day passed to [RtGam()]. To extract a 7 day-ahead forecast, pass
#'  `predict(RtGamFit, horizon = 7)`.
#' 3. Specifying `min_date` and `horizon`. Predictions are returned for the
#'   period from `min_date` through `horizon` days after last day passed
#'   to [RtGam()].
#' 4. Specifying `min_date` and `max_date`. Predictions are returned for each day
#'   between these two dates (inclusive).
#'
#' @export
predict.RtGam <- function(
    object,
    type,
    horizon = NULL,
    min_date = NULL,
    max_date = NULL,
    n = 10,
    mean_delay = NULL,
    gi_pmf,
    seed = 12345,
    ...) {
  rlang::arg_match(type,
    values = c(
      "obs_cases",
      "incidence",
      "r",
      "Rt"
    ),
    call = rlang::caller_env()
  )
  desired_dates <- parse_predict_dates(
    object = object,
    min_date = min_date,
    max_date = max_date,
    horizon = horizon
  )
  timesteps <- prep_timesteps_for_pred(
                  type = type,
        min_date = object[["min_date"]],
       max_date = object[["max_date"]]
)

  if (type == "obs_cases") {
    desired_dates <- seq.Date(
      from = min_date,
      to = max_date,
      by = "day"
      # TODO: does this handle doubles properly? How should they be handled?
    )

    timesteps <- dates_to_timesteps(desired_dates,
      min_supplied_date = object[["min_date"]],
      max_supplied_date = object[["max_date"]]
    )
    newdata <- data.frame(
      timestep = timesteps,
      .row = seq_along(timesteps),
      reference_date = desired_dates
    )

    fitted <- gratia::posterior_samples(
      object[["model"]],
      data = newdata,
      unconditional = TRUE,
      ...
    )
    print(head(fitted))
  } else if (type == "incidence") {
    # I'm breaking it out because we're going to want to also remove day of week effect I think.
    if (!rlang::is_bare_numeric(mean_delay)) {
      cli::cli_abort("{.arg mean_delay} is required when {.arg type} is {.val obs_incidence}")
    }

    # Extract incidence at mean-shifted dates
    desired_dates <- seq.Date(
      from = min_date,
      to = max_date,
      by = "day"
      # TODO: does this handle doubles properly? How should they be handled?
    )

    # Shift desired dates _forward_ to get the corresponding date in fitted cases
    mean_shifted_dates <- desired_dates + mean_delay


    timesteps <- dates_to_timesteps(mean_shifted_dates,
      min_supplied_date = object[["min_date"]],
      max_supplied_date = object[["max_date"]]
    )

    # And associate the timestep with the incidence date, not the case date to shift back from cases to incidence
    newdata <- data.frame(
      timestep = timesteps,
      .row = seq_along(timesteps),
      reference_date = desired_dates
    )

    # Use `posterior_samples()` over `fitted_samples()` to get response w/ obs uncertainty
    fitted <- gratia::posterior_samples(
      object[["model"]],
      data = newdata,
      unconditional = TRUE,
      ...
    )
  } else if (type == "r") {
    if (!rlang::is_bare_numeric(mean_delay)) {
      cli::cli_abort("{.arg mean_delay} is required when {.arg type} is {.val obs_incidence}")
    }

    # Extract incidence at mean-shifted dates
    desired_dates <- seq.Date(
      from = min_date,
      to = max_date,
      iy = "day"
    )

    # Shift desired dates _forward_ to get the corresponding date in fitted cases
    mean_shifted_dates <- desired_dates + mean_delay


    timesteps <- dates_to_timesteps(mean_shifted_dates,
      min_supplied_date = object[["min_date"]],
      max_supplied_date = object[["max_date"]]
    )

    # Construct timesteps as with incidence and shift by delta for discrete derivative
    newdata <- data.frame(
      timestep = timesteps,
      reference_date = desired_dates
    )
    delta <- 1e-9
    timesteps_shifted <- timesteps + delta
    print(head(timesteps))
    print(head(timesteps_shifted))
    all_timesteps <- c(rbind(timesteps, timesteps_shifted))
    print(head(all_timesteps))
    # `rbind()` interleaves vectors, so we can difference them
    ds <- gratia::data_slice(fit[["model"]], timestep = all_timesteps)

    all_timesteps <- gratia::fitted_samples(
      object[["model"]],
      data = ds,
      n = n,
      seed = seed,
      unconditional = TRUE,
      scale = "response",
      ...
    )
    is_orig_timestep <- all_timesteps[[".row"]] %% 2 == 1
    differenced_draws <- all_timesteps[[".fitted"]][is_orig_timestep] - all_timesteps[[".fitted"]][!is_orig_timestep]
    print(head(differenced_draws))
    growth_rate <- differenced_draws[is_orig_timestep] / delta
    print(head(growth_rate))
    fitted <- data.frame(
      .response = growth_rate,
      .row = 1:length(growth_rate),
      .draw = all_timesteps[[".draw"]][is_orig_timestep],
      timestep = timesteps
    )
    print(head(fitted))
  } else {
    cli::cli_abort("Not implemented")
  }

  merged <- merge(fitted,
    newdata,
    by = "timestep"
  )

  data.frame(
    reference_date = merged[["reference_date"]],
    .response = merged[[".response"]],
    .draw = merged[[".draw"]]
  )
}

#' Convert from user specification to necessary date range
#'
#' @inheritParams predict.RtGam
#' @param call The calling environment to be reflected in the error message
#'
#' @return List with two elements: min_date and max_date
parse_predict_dates <- function(
  object,
  min_date = NULL,
  max_date = NULL,
  horizon = NULL,
  call = rlang::caller_env()
) {
  if (!rlang::is_null(min_date)) check_date(min_date, call = call)
  if (!rlang::is_null(max_date)) check_date(max_date, call = call)
  if (!rlang::is_null(horizon)) check_integer(horizon, call = call)

  # Handle horizon to estimate dates if provided
  if (!is.null(horizon)) {
    rlang::check_exclusive(max_date, horizon, call = call)
    min_date <- min_date %||% (object[["max_date"]] + 1)
    max_date <- object[["max_date"]] + horizon + 1
  } else {
    # Default to object's date range if not specified
    min_date <- min_date %||% object[["min_date"]]
    max_date <- max_date %||% object[["max_date"]]
  }

  # Ensure min_date is before max_date
  if (min_date >= max_date) {
    cli::cli_warn(c(
      "Swapping {.arg min_date} and {.arg max_date}",
      "{.arg min_date} {.val {min_date}} is after {.arg max_date} {.val {max_date}}"
    ),
    class = "RtGam_predict_dates_backward",
    call = call
   )
   temp_var <- max_date
   max_date <- min_date
   min_date <- temp_var
  }

  list(min_date = as.Date(min_date), max_date = as.Date(max_date))
}

#' Convert from user-specified dates to internal timesteps
#'
#' @inheritParams predict.RtGam
#' @return Double vector, the timesteps to predict
prep_timesteps_for_pred <- function(
type,
min_date,
max_date,
mean_delay
call = rlang::caller_env()
) {

  if (type == "incidence" || type == "growth_rate") {
    # Shift cases up by mean delay to get projected incidence on day
    min_date = min_date + mean_delay
    max_date = max_date + mean_delay
  } else if (type == "Rt")
     # Shift up by mean delay to move to incidence scale and also pad by the
     # GI on either side to prevent missing dates in the convolution
     min_date = min_date + mean_delay - length(gi_pmf)
    max_date = max_date + mean_delay + length(gi_pmf)
  }

}
