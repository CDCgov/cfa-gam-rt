---
title: "Simulating and running HGAMs on spatio-temporal data"
author: "Adam Howes"
date: "`r Sys.Date()`"
output: html_document
---

```{r}
knitr::opts_chunk$set(error = TRUE)

suppressPackageStartupMessages({
  library(RtGam)
  library(ggplot2)
  library(gamtools)
  library(sf)
  library(dplyr)
  library(patchwork)
})

set.seed(1)
```

Plan:

1. Understand `simulate_sir` function
1. Extend `simulate_sir` to generate reporting triangle data
1. Create fake counties spatial structure
1. Simulate correlation structures for the fake counties
1. Create time series of $R_t$ with some spatio-temporal structure
1. Apply `simulate_sir` to each county
1. Extract data and format for input to `gamtools::prep_model_df`
1. Run model with `gamtools::run_model()`
1. Visualise results
1. Perform integration testing checks ready for e.g. `testthat` setting

## 1.

```{r}
sir <- simulate_sir(
  Rt = 0.5 * sin(seq_len(100)/10 * pi) + 1,
  S0 = 99000,
  I0 = 1000,
  R0 = 0,
  gamma = 0.5,
  delay_pmf = c(0.1, 0.2, 0.3, 0.4),
  k = 10,
  seed = 12345,
  date0 = as.Date("2023-01-01"),
  day_of_week = FALSE
)

ggplot(sir, aes(x = reference_date, y = value, col = parameter)) +
  geom_line() +
  theme_minimal() +
  facet_wrap(~parameter, scales = "free")
```

## 2.

The `simulate_sir()` function currently doesn't generate reporting triangle data.
Here I will extend it to do so:

```{r}
sir$parameter |> unique()

reporting_delay_pmf <- c(0.6, 0.2, 0.1, 0.05, 0.05)

create_reporting_triangle <- function(sir, reporting_delay_pmf) {
  L <- length(reporting_delay_pmf)

  cases_df <- filter(sir, parameter == "observed_incident_cases") |>
    mutate(value = tidyr::replace_na(value, 0))

  cases_df |>
    rowwise() |>
    mutate(
      delay = list(0:(L - 1)),
      report_date = list(reference_date + 0:(L - 1)),
      cumulative_observed_cases = list(cumsum(rmultinom(n = 1, size = value, prob = reporting_delay_pmf))),
    ) |>
    tidyr::unnest(c(delay, report_date, cumulative_observed_cases)) |>
    select(reference_date, report_date, delay, cumulative_observed_cases)
}

reporting_triangle <- create_reporting_triangle(sir, reporting_delay_pmf)

ggplot(reporting_triangle, aes(x = reference_date, y = cumulative_observed_cases, col = as.factor(delay))) +
  geom_point() +
  scale_color_viridis_d() +
  labs(
    x = "Reference date",
    y = "Cumulative observed cases",
    col = "Delay"
  ) +
  theme_minimal()
```

## 3.

```{r}
create_sf_grid <- function(height, width){
  sfc <- sf::st_sfc(sf::st_polygon(list(rbind(c(0, 0), c(width, 0), c(width, height), c(0, 0)))))
  grid <- sf::st_make_grid(sfc, cellsize = 1, square = TRUE)
  return(grid)
}

geometry <- create_sf_grid(height = 4, width = 4)

state_fips_code <- "99"
county_fips_code <- stringr::str_pad(seq_along(geometry), width = 3, pad = "0")
fips <- paste0(state_fips_code, county_fips_code)

sf <- sf::st_sf(geometry) |>
  mutate(fips = fips)

ggplot(sf) +
  geom_sf() +
  geom_sf_text(aes(label = fips)) +
  theme_void() +
  labs(title = "Mocked counties")
```

## 4.

```{r}
plot_matrix <- function(M, limits = NULL) {
  ggplot(
    reshape2::melt(M),
    aes(x = .data$Var1, y = .data$Var2, fill = .data$value)
  ) +
    labs(x = "", y = "", fill = "Value") +
    geom_tile() +
    scale_fill_viridis_c(limits = limits) +
    theme_void()
}

space_cov <- function(d, range, sill) {
  sill * exp(-d / range)
}

time_cov <- function(lag, rho) {
  rho^lag
}

reference_date <- seq.Date(
  from = as.Date("2025-01-01"),
  by = "day",
  length.out = 60
)

time_dist <- dist(reference_date) |> as.matrix()
time_cov <- time_cov(time_dist, rho = 0.9)

space_dist <- sf::st_distance(sf::st_centroid(sf)) |>
  as.matrix()

space_cov <- space_cov(
  space_dist,
  range = as.numeric(mean(space_dist)), sill = 1
)

space_time_cov <- kronecker(space_cov, time_cov)

time_corr <- plot_matrix(time_cov, limits = c(0, 1)) + labs(title = "Temporal", fill = "Correlation")
space_corr <- plot_matrix(space_cov, limits = c(0, 1)) + labs(title = "Spatial", fill = "Correlation")
space_time_corr <- plot_matrix(space_time_cov, limits = c(0, 1)) + labs(title = "Spatio-temporal", fill = "Correlation")

time_corr + space_corr

space_time_corr
```

## 5.

We will use a model like
$$
R_t = \mu_t + u_s + v_{st},
$$
where:

* $\mu_t$ is a smooth temporal trend
* $u_s$ is a spatially varying intercept
* $w_{st}$ is a spatio-temporal interaction

```{r}
n <- length(reference_date)

mu <- 0.5 * sin(seq_len(n) / 5 * pi) - 0.1

mu_df <- data.frame(
  reference_date = reference_date,
  mu = mu
)

u_sd <- 0.1
u <- MASS::mvrnorm(
  n = 1,
  mu = rep(0, nrow(space_cov)),
  Sigma = u_sd * space_cov
)

u_df <- data.frame(
  fips = factor(fips, levels = fips),
  u = u
)

v_sd <- 0.2
v <- MASS::mvrnorm(
  n = 1,
  mu = rep(0, nrow(space_time_cov)),
  Sigma = v_sd * space_time_cov
)

rt_df <- tidyr::expand_grid(
  reference_date = reference_date,
  fips = factor(fips, levels = fips)
) |>
  left_join(
    mu_df,
    by = "reference_date"
  ) |>
  left_join(
    u_df,
    by = "fips"
  ) |>
  dplyr::mutate(
    v = v,
    rt = log(1 + exp(mu + u + v))
  )

rt_plot <- ggplot(rt_df, aes(x = reference_date, y = rt, col = fips)) +
  geom_line() +
  theme_minimal() +
  facet_wrap(. ~ fips, scales = "free_y")

mu_plot <- ggplot(mu_df, aes(x = reference_date, y = mu)) +
  geom_line() +
  labs(title = "Temporal effect") +
  theme_minimal()

u_plot <- ggplot(u_df, aes(x = fips, y = u)) +
  geom_point() +
  labs(title = "Spatial effect") +
  theme_minimal()

v_plot <- ggplot(rt_df, aes(x = reference_date, y = v, col = fips)) +
  geom_line() +
  labs(title = "Spatio-temporal effect") +
  theme_minimal() +
  theme(
    legend.position = "right"
  )

rt_plot
mu_plot / u_plot
v_plot
```

## 6.

```{r}
sir_reporting_fips <- function(fips) {
  rt <- rt_df |>
    filter(fips == .env$fips) |>
    arrange(reference_date) |>
    pull(rt)
  
  sir <- simulate_sir(
    Rt = rt,
    S0 = 99000,
    I0 = 1000,
    R0 = 0,
    gamma = 0.5,
    delay_pmf = c(0.1, 0.2, 0.3, 0.4),
    k = 10,
    seed = 12345,
    date0 = as.Date("2023-01-01"),
    day_of_week = FALSE
  )
  
  reporting_triangle <- create_reporting_triangle(
    sir,
    reporting_delay_pmf = c(0.6, 0.2, 0.1, 0.05, 0.025, 0.025)
  ) |>
    mutate(fips_code = .env$fips, .before = "reference_date") |>
    rename(count_target = cumulative_observed_cases)
  
  return(reporting_triangle)
}

df <- purrr::map_dfr(fips, sir_reporting_fips)
```

## 6.

```{r}
prep <- df |>
  mutate(
    api_version = NA,
    count_total = 1e+05,
  ) |>
  gamtools::prep_model_df(report_date = max(df$report_date), nowcast_days = 4)


ggplot(prep, aes(x = reference_date, y = count_target, col = as.factor(delay))) +
  geom_point() +
  scale_color_viridis_d() +
  facet_wrap(~fips_code, scales = "free") +
  labs(
    x = "Reference date",
    y = "Cumulative observed cases",
    col = "Delay"
  ) +
  theme_minimal()
```

## 7.

```{r}
n_distinct(prep$ts)

per_fips_delay <- prep |>
  group_by(fips_code) |>
  summarise(n_delay = n_distinct(effective_delay), .groups = "drop")

min_delay_per_fips <- min(per_fips_delay$n_delay)

n_pair_fips_ts <- n_distinct(interaction(prep$fips_code, prep$ts, drop = TRUE))

fit <- gamtools::fit_model(
  df = prep, network = "none"
)

summary(fit)
```

## 8.

```{r}
pred <- prep |>
  mutate(geo_value = NA) |>
  prep_prediction_df(
    nowcast_days = 4,
  ) |>
  add_posterior_predictions(fit)
```


## Alternative approach {-}

Alternative is to come from simulating data to go straight into the HGAM code:

```{r}
fake_reporting_triangle <- function(
    fips = c("01001", "01003", "01005"),
    nowcast_days = 6,
    end_date = as.Date("2025-07-07")
) {
  tidyr::expand_grid(
    report_date = seq(end_date - nowcast_days * 7, end_date, by = "week"),
    delay = 0:nowcast_days,
    fips_code = fips
  ) |>
    mutate(
      reference_date = report_date - delay,
      count_target = 10 + delay + as.integer(factor(fips_code)),
      count_ddi = 8 + delay + as.integer(factor(fips_code)),
      count_total = 15 + delay + as.integer(factor(fips_code)),
      api_version = "v1"
    )
}

tri <- fake_reporting_triangle()
prep <- gamtools::prep_model_df(tri, report_date = max(tri$report_date), nowcast_days = 6, denominator = "count_total")
fit_none <- gamtools::fit_model(df = prep, network = "none")
```
