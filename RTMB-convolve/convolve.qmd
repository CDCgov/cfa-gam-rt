---
title: "RTMB-convolution fitting of case reports"
date: today
format:
  html:
    code-fold: true
    code-summary: "Show the code"
    embed-resources: true
---

Relevant [GH issue](https://github.com/CDCgov/cfa-gam-rt/issues/88)

```{r pkgs, message = FALSE}
library(RtGam)
library(dplyr)
library(ggplot2); theme_set(theme_bw())
library(mgcv)
library(glmmTMB)
library(RTMB)
library(broom.mixed) ## for augment etc.
source(here::here("RTMB-convolve","convolve_funs.R"))
```


Use default from `simulate_sir()` for now:

```{r defaults}
delay_pmf <- (1:4)/10
delay_mean <- sum(seq_along(delay_pmf)*delay_pmf)
```

Simulate with neg bin etc (accept defaults)
```{r sim1}
set.seed(101)
sim0 <- simulate_sir() |>
  mutate(rdate = as.numeric(reference_date - min(reference_date)))
```

Will want to compare true_rt, true_incident_cases
also, maybe, true growth rate? (maybe adjust code to
return true_Rt and true_rt/true_growth? Back-calculating
r from R seems mildly tedious

```{r sim0}
dd <- sim0 |>
  filter(parameter == "observed_incident_cases") |>
  select(date = reference_date, rdate, value)
```

```{r plot-sim}
plot(value ~ rdate, dd)
```

Regular fit (ignore delays)
using REML because most (?) reliable for estimating degree of smoothing
bump `k` up from default ...


```{r fit-gam}
m1 <- gam(value ~ s(rdate, k = 20), family = "nb", data = dd, method = "REML")
plot(m1)
```

Confirming that glmmTMB can fit the same (unshifted/unconvolved) model

Have to start glmmTMB with a larger-than-default SD for the spline
term ... otherwise collapses (could check profile etc etc). (Default `theta` (= log-SD for spline term)
start value is 0, bump it up to 3 ...)

```{r fit-glmmTMB}
m2 <- glmmTMB(value ~ s(rdate, k = 20), family = nbinom2, data = dd,
              REML = TRUE, start = list(theta = 3))
```


```{r plot2}
plot(predict(m2))
lines(predict(m1), col = 2)
```

(`predict.gam` returns an odd named structure, have to mangle it to compare)
```{r check-equal}
stopifnot(all.equal(unname(c(predict(m1))), predict(m2), tolerance = 1e-6))
```

Now use the glmmTMB model structure to fit a model with convolution instead

### Create TMB-data object

(glmmTMB handles calls to `smoothCon`, `smooth2random(sm, vnames = "", type = 2)`;
might eventually want to disentangle/extract that code)

This could be done more compactly with `update(..., doFit=FALSE)` but clearer in 
this case to let things be self-contained.

```{r setup-convolve}
m3 <- glmmTMB(value ~ s(rdate, k = 20), family = nbinom2, data = dd,
              REML = TRUE, start = list(theta = 3), doFit = FALSE)
data.tmb <- c(m3$data.tmb, list(delay_pmf = delay_pmf))
pars0 <- nz_elements(m3$parameters)
```

Base-R, AD versions are identical if no random effects/Laplace approx:

```{r compare-nll}
nll_convolve(pars0)
ff <- MakeADFun(nll_convolve, pars0)
ff$fn()
## no longer the same if we add LA
ff2 <- MakeADFun(nll_convolve, pars0, random = "b", silent = TRUE)
ff2$fn()
```

```{r fit-convolve}
fit <- with(ff2, nlminb(par, fn, gr))
plot(ff2$report()$mu)
```

Get predictions and CIs

```{r calc-preds}
obs_tvec <- unique(dd$rdate)
pp <- predict(m1, se.fit = TRUE)
mgcv_res <- tibble(parameter = "mgcv",
                   rdate = obs_tvec-delay_mean,
                   value = exp(pp$fit),
                   lwr = exp(pp$fit - 1.96*pp$se.fit),
                   upr = exp(pp$fit + 1.96*pp$se.fit))

RTMB_res <- RTMB::sdreport(ff2) |>
  summary() |>
  as.data.frame() |>
  tibble::rownames_to_column("param") |>
  filter(grepl("^etac", param)) |>
  transmute(
    parameter = "RTMB",
    rdate = 0:99,
    value = Estimate,
    lwr = Estimate - 1.96*`Std. Error`,
    upr = Estimate + 1.96*`Std. Error`) |>
  mutate(across(c(value, lwr, upr), exp))

res1 <- sim0 |>
  filter(parameter == "incident_infections") |>
  bind_rows(RTMB_res, mgcv_res)
```

In this case mean-shifting and convolution do about equally well

```{r plot-preds}
ggplot(res1, aes(rdate, value)) + geom_line(aes(colour = parameter)) +
  geom_ribbon(aes(fill = parameter, ymin = lwr, ymax = upr),
              colour = NA, alpha = 0.2) +
  labs(x = "date", y = "incidence")
## (warning from NA values in true infections)
```

## Testing encapsulated machinery

```{r encapsulate}
m3 <- fit_RTMB_convolve(value ~ s(rdate, k = 20),
                        family = nbinom2, data = dd,
                        start = list(theta = 3),
                        delay_pmf = delay_pmf)
a3 <- augment(m3)
ggplot(a3, aes(rdate, value, colour = parameter)) +
  geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr, fill = parameter),
              colour = NA, alpha = 0.3)
```

Will want to compare true_rt, true_incident_cases
also, maybe, true growth rate? (maybe adjust code to
return true_Rt and true_rt/true_growth? Back-calculating
r from R seems mildly tedious

## Further encapsulation

```{r sim-and-fit}
simfit <- function(delay_pmf , nt = 100, theta = 3, seed = 101, k = 20) {
  Rt <- 0.5 * sin(seq_len(nt)/10 * pi) + 1  ## default Rt
  sim0 <- simulate_sir(Rt = Rt, delay_pmf = delay_pmf, seed = seed) |>
    dplyr::mutate(rdate = as.numeric(reference_date - min(reference_date)))
  ## sim0 has parameter in {"S","I","R","true_rt","incident_infections","true_incident_cases",
  ## "observed_incident_cases"
  ##
  ## get observed incident cases
  dd0 <- sim0 |>
    dplyr::filter(parameter == "observed_incident_cases") |>
    dplyr::select(date = reference_date, rdate, value)
  ## fancy evaluation to evaluate k here
  ## (need to coerce it *back* into a formula ...)
  form <- as.formula(bquote(value ~ s(rdate, k = .(k))))
  m <- fit_RTMB_convolve(form,
                         family = nbinom2, data = dd0,
                         start = list(theta = 3),
                         delay_pmf = delay_pmf)

  ## careful with matching up rdates (reference dates)
  ## augment() assumes starting with zero
  aa <- augment(m) |>
    dplyr::full_join(x = distinct(select(sim0, rdate)), by = "rdate")
  
  gam_fit <- gam(value ~ s(rdate, k = k), family = "nb", data = dd0, method = "REML",
                 na.action = na.exclude) ## na.exclude includes initial rdates
  gam_pred0 <- predict(gam_fit, type = "link", se.fit = TRUE)
  gam_pred <- with(gam_pred0, tibble(rdate = dd0$rdate,
                                     parameter = "gam_fit_unshifted",
                                     value = exp(c(fit)),
                                     lwr = exp(c(fit)-1.96*c(se.fit)),
                                     upr = exp(c(fit)+1.96*c(se.fit))))
  sum_pmf <- sum(delay_pmf)
  if (!isTRUE(all.equal(sum_pmf, 1.0))) warning("sum of pmf != 1 (%1.2g)", sum_pmf)
  mean_delay <- sum(seq_along(delay_pmf)*delay_pmf)
  gam_pred_shifted <- gam_pred |>
    mutate(parameter = "gam_fit_shifted",
           across(c(value, lwr, upr), ~ dplyr::lead(., round(mean_delay), default = NA)))
  ## do we want incident_infections?
  aa <- dplyr::bind_rows(filter(sim0,
                                parameter %in%
                                c("incident_infections", "observed_incident_cases", "true_incident_cases")),
                         ## double-check augment(), why do we have 10 NA rows at the end?
                         na.omit(aa),
                         gam_pred,
                         gam_pred_shifted)
  class(aa) <- c("RTMB_simfit", class(aa))
  return(aa)
}
```

(Needed to bump up to `k=50`)
```{r simfit0}
pmf0 <- c(rep(0, 10), 1)
ss <- simfit(delay_pmf = pmf0, seed = 103, k = 50)
## here gam-fit-shifted is indistinguishable from true incident infections
ggfit0 <- ggplot(ss, aes(rdate, value, colour = parameter)) +
  geom_line() + geom_point(aes(shape=parameter)) ## + facet_wrap(~parameter)
print(ggfit0)
```

Now a more extreme delay distribution ...
```{r simfit1}
pmf1 <- c(rep(0.1, 10))
ss1 <- simfit(delay_pmf = pmf1, seed = 103, k = 50)
## here gam-fit-shifted is indistinguishable from true incident infections
incvals <- c("incident_infections", "gam_fit_shifted", "mu")
## ggfit0 %+% ss1
print(ggfit0 %+% filter(ss1, parameter %in% incvals) +
      geom_ribbon(aes(ymin = lwr, ymax = upr, fill = parameter), colour = NA, alpha = 0.3))
  ## facet_wrap(~parameter))
```

## To do 

* double-check what we're assuming in first example -- are we reporting estimated delayed vals or estimated original vals?
* further encapsulation (sims + fits with specified delay-pmf, automatic plots/comparisons to mgcv fit)
* more extreme tests
* work out how to do stuff with factor/by smooths (whatever RtGam is currently using ...) -- see what breaks (should be transferrable back to glmmTMB ...)
* will need extra machinery for prediction
* computational cost?
* fragility?
* end effects?
* bam?????
